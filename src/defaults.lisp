(in-package :cl-indentify)

(defparameter +common-lisp-templates+
  '((assert :count 2)
    (block :count 0)
    (case :count 1 :secondary (:count 0))
    (catch :count 1)
    (ccase :count 1 :secondary (:count 0))
    (cond :count 0 :secondary (:count 0))
    (ctypecase :count 1 :secondary (:count 0))
    (decf :count 1)
    (defclass :count 2)
    (defconstant :count 1)
    (defgeneric :count 2)
    (define-compiler-macro :count 2)
    (define-condition :count 1)
    (define-method-combination :count 2)
    (define-modify-macro :count 2)
    (define-setf-expander :count 2)
    (define-symbol-macro :count 2)
    (defmacro :count 2)
    (defmethod :count 2 :ignore (:before :after :around))
    (defpackage :count 1)
    (:shadowing-import-from :count 1)
    (:import-from :count 1)
    (defparameter :count 1)
    (defsetf :count 2)
    (defstruct :count 1)
    (deftype :count 1)
    (defun :count 2)
    (defvar :count 1)
    (destructuring-bind :count 2)
    (do :count 2)
    (do* :count 2)
    (do-all-symbols :count 1)
    (do-external-symbols :count 1)
    (dolist :count 1)
    (do-symbols :count 1)
    (dotimes :count 1)
    (ecase :count 1 :secondary (:count 0))
    (etypecase :count 1 :secondary (:count 0))
    (eval-when :count 1)
    (flet :count 1)
    (handler-bind :count 0)
    (handler-case :count 1 :secondary (:count 1))
    (if :count 1)
    (incf :count 1)
    (labels :count 1)
    (lambda :count 1)
    (let :count 1)
    (let* :count 1)
    (let-values :count 1)
    (loop :count 0)
    (macrolet :count 1)
    (multiple-value-bind :count 2)
    (multiple-value-prog1 :count 0)
    (prog1 :count 0)
    (prog2 :count 0)
    (prog :count 1)
    (prog* :count 1)
    (progn :count 0)
    (progv :count 2)
    (setf :count 1)
    (typecase :count 1 :secondary (:count 0))
    (unless :count 1)
    (unwind-protect :count 1)
    (when :count 1)
    (with-input-from-string :count 1)
    (with-open-file :count 1)
    (with-open-socket :count 1)
    (with-open-stream :count 1)
    (with-output-to-string :count 1)
    (with-slots :count 2)))

(defparameter +asdf-templates+
  '((asdf:defsystem :count 1)))

(defparameter +uiop-templates+
  '((uiop:while-collecting :count 1)
    (uiop:with-current-directory :count 1)
    (uiop:with-deprecation :count 1)
    (uiop:with-enough-pathname :count 1)
    (uiop:with-fatal-condition-handler :count 1)
    (uiop:with-input :count 1)
    (uiop:with-muffled-compiler-conditions :count 1)
    (uiop:with-muffled-conditions :count 1)
    (uiop:with-muffled-loader-conditions :count 1)
    (uiop:with-null-input :count 1)
    (uiop:with-null-output :count 1)
    (uiop:with-output :count 1)
    (uiop:with-safe-io-syntax :count 1)
    (uiop:with-saved-deferred-warnings :count 1)
    (uiop:with-staging-pathname :count 1)
    (uiop:with-temporary-file :count 1)
    (uiop:with-upgradability :count 1)))

(defparameter +alexandria-templates+
  '((alexandria:cswitch :count 1 :secondary (:count 0))
    (alexandria:destructuring-case :count 1 :secondary (:count 0))
    (alexandria:destructuring-ccase :count 1 :secondary (:count 0))
    (alexandria:destructuring-ecase :count 1 :secondary (:count 0))
    (alexandria:eswitch :count 1 :secondary (:count 0))
    (alexandria:if-let :count 1)
    (alexandria:named-lambda :count 2)
    (alexandria:once-only :count 1)
    (alexandria:switch :count 1 :secondary (:count 0))
    (alexandria:when-let :count 1)
    (alexandria:when-let* :count 1)
    (alexandria:with-gensyms :count 1)
    (alexandria:with-unique-names :count 1)))

